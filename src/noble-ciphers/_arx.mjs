/* esm.sh - @noble/ciphers@2.0.1/_arx */
import{abool as B,abytes as L,anumber as x,checkOpts as v,clean as K,copyBytes as C,randomBytes as _,u32 as p}from"./utils.mjs";var N=r=>Uint8Array.from(r.split(""),t=>t.charCodeAt(0)),R=N("expand 16-byte k"),$=N("expand 32-byte k"),P=p(R),S=p($);function F(r,t){return r<<t|r>>>32-t}function A(r){return r.byteOffset%4===0}var m=64,T=16,O=2**32-1,M=Uint32Array.of();function q(r,t,e,s,i,h,o,a){let n=i.length,d=new Uint8Array(m),f=p(d),u=A(i)&&A(h),g=u?p(i):M,w=u?p(h):M;for(let y=0;y<n;o++){if(r(t,e,s,f,o,a),o>=O)throw new Error("arx: counter overflow");let b=Math.min(m,n-y);if(u&&b===m){let l=y/4;if(y%4!==0)throw new Error("arx: invalid block position");for(let c=0,k;c<T;c++)k=l+c,w[k]=g[k]^f[c];y+=m;continue}for(let l=0,c;l<b;l++)c=y+l,h[c]=i[c]^d[l];y+=b}}function Y(r,t){let{allowShortKeys:e,extendNonceFn:s,counterLength:i,counterRight:h,rounds:o}=v({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},t);if(typeof r!="function")throw new Error("core must be a function");return x(i),x(o),B(h),B(e),(a,n,d,f,u=0)=>{L(a,void 0,"key"),L(n,void 0,"nonce"),L(d,void 0,"data");let g=d.length;if(f===void 0&&(f=new Uint8Array(g)),L(f,void 0,"output"),x(u),u<0||u>=O)throw new Error("arx: counter overflow");if(f.length<g)throw new Error(`arx: output (${f.length}) is shorter than data (${g})`);let w=[],y=a.length,b,l;if(y===32)w.push(b=C(a)),l=S;else if(y===16&&e)b=new Uint8Array(32),b.set(a),b.set(a,16),l=P,w.push(b);else throw L(a,32,"arx key"),new Error("invalid key size");A(n)||w.push(n=C(n));let c=p(b);if(s){if(n.length!==24)throw new Error("arx: extended nonce must be 24 bytes");s(l,c,p(n.subarray(0,16)),c),n=n.subarray(16)}let k=16-i;if(k!==n.length)throw new Error(`arx: nonce must be ${k} or 16 bytes`);if(k!==12){let U=new Uint8Array(12);U.set(n,h?0:12-n.length),n=U,w.push(n)}let j=p(n);return q(r,l,c,j,d,f,u,o),K(...w),f}}var E=class r{blockLen;keyLen;nonceLen;state;buf;key;nonce;pos;ctr;cipher;constructor(t,e,s,i,h){this.cipher=t,this.blockLen=e,this.keyLen=s,this.nonceLen=i,this.state=new Uint8Array(this.keyLen+this.nonceLen),this.reseed(h),this.ctr=0,this.pos=this.blockLen,this.buf=new Uint8Array(this.blockLen),this.key=this.state.subarray(0,this.keyLen),this.nonce=this.state.subarray(this.keyLen)}reseed(t){if(L(t),!t||t.length===0)throw new Error("entropy required");for(let e=0;e<t.length;e++)this.state[e%this.state.length]^=t[e];this.ctr=0,this.pos=this.blockLen}addEntropy(t){this.state.set(this.randomBytes(this.state.length)),this.reseed(t)}randomBytes(t){if(x(t),t===0)return new Uint8Array(0);let e=new Uint8Array(t),s=0;if(this.pos<this.blockLen){let o=Math.min(t,this.blockLen-this.pos);if(e.set(this.buf.subarray(this.pos,this.pos+o),0),this.pos+=o,s+=o,s===t)return e}let i=Math.floor((t-s)/this.blockLen);if(i>0){let o=i*this.blockLen,a=e.subarray(s,s+o);this.cipher(this.key,this.nonce,a,a,this.ctr),this.ctr+=i,s+=o}let h=t-s;return h>0&&(this.buf.fill(0),this.cipher(this.key,this.nonce,this.buf,this.buf,this.ctr++),e.set(this.buf.subarray(0,h),s),this.pos=h),e}clone(){return new r(this.cipher,this.blockLen,this.keyLen,this.nonceLen,this.randomBytes(this.state.length))}clean(){this.pos=0,this.ctr=0,this.buf.fill(0),this.state.fill(0)}},D=(r,t,e,s)=>(i=_(32))=>new E(r,t,e,s,i);export{E as _XorStreamPRG,Y as createCipher,D as createPRG,F as rotl};
//# sourceMappingURL=_arx.mjs.map

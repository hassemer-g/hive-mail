/* esm.sh - @noble/ciphers@2.0.1/utils */
function h(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function w(e){if(typeof e!="boolean")throw new Error(`boolean expected, not ${e}`)}function x(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function s(e,t,n=""){let r=h(e),o=e?.length,i=t!==void 0;if(!r||i&&o!==t){let f=n&&`"${n}" `,c=i?` of length ${t}`:"",u=r?`length=${o}`:`type=${typeof e}`;throw new Error(f+"expected Uint8Array"+c+", got "+u)}return e}function N(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function C(e,t){s(e,void 0,"output");let n=t.outputLen;if(e.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}function S(e){return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}function V(e){return new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4))}function _(...e){for(let t=0;t<e.length;t++)e[t].fill(0)}function b(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}var A=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68,a=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",m=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function E(e){if(s(e),a)return e.toHex();let t="";for(let n=0;n<e.length;n++)t+=m[e[n]];return t}var d={_0:48,_9:57,A:65,F:70,a:97,f:102};function l(e){if(e>=d._0&&e<=d._9)return e-d._0;if(e>=d.A&&e<=d.F)return e-(d.A-10);if(e>=d.a&&e<=d.f)return e-(d.a-10)}function U(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);if(a)return Uint8Array.fromHex(e);let t=e.length,n=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);let r=new Uint8Array(n);for(let o=0,i=0;o<n;o++,i+=2){let f=l(e.charCodeAt(i)),c=l(e.charCodeAt(i+1));if(f===void 0||c===void 0){let u=e[i]+e[i+1];throw new Error('hex string expected, got non-hex character "'+u+'" at index '+i)}r[o]=f*16+c}return r}function B(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return BigInt(e===""?"0":"0x"+e)}function I(e){return B(E(e))}function $(e,t){return U(e.toString(16).padStart(t*2,"0"))}function j(e){if(typeof e!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}function v(e){return new TextDecoder().decode(e)}function O(e,t){return e.buffer===t.buffer&&e.byteOffset<t.byteOffset+t.byteLength&&t.byteOffset<e.byteOffset+e.byteLength}function D(e,t){if(O(e,t)&&e.byteOffset<t.byteOffset)throw new Error("complex overlap of input and output is not supported")}function T(...e){let t=0;for(let r=0;r<e.length;r++){let o=e[r];s(o),t+=o.length}let n=new Uint8Array(t);for(let r=0,o=0;r<e.length;r++){let i=e[r];n.set(i,o),o+=i.length}return n}function R(e,t){if(t==null||typeof t!="object")throw new Error("options must be defined");return Object.assign(e,t)}function k(e,t){if(e.length!==t.length)return!1;let n=0;for(let r=0;r<e.length;r++)n|=e[r]^t[r];return n===0}var F=(e,t)=>{function n(r,...o){if(s(r,void 0,"key"),!A)throw new Error("Non little-endian hardware is not yet supported");if(e.nonceLength!==void 0){let p=o[0];s(p,e.varSizeNonce?void 0:e.nonceLength,"nonce")}let i=e.tagLength;i&&o[1]!==void 0&&s(o[1],void 0,"AAD");let f=t(r,...o),c=(p,y)=>{if(y!==void 0){if(p!==2)throw new Error("cipher output not supported");s(y,void 0,"output")}},u=!1;return{encrypt(p,y){if(u)throw new Error("cannot encrypt() twice with same key + nonce");return u=!0,s(p),c(f.encrypt.length,y),f.encrypt(p,y)},decrypt(p,y){if(s(p),i&&p.length<i)throw new Error('"ciphertext" expected length bigger than tagLength='+i);return c(f.decrypt.length,y),f.decrypt(p,y)}}}return Object.assign(n,e),n};function q(e,t,n=!0){if(t===void 0)return new Uint8Array(e);if(t.length!==e)throw new Error('"output" expected Uint8Array of length '+e+", got: "+t.length);if(n&&!L(t))throw new Error("invalid output, must be aligned");return t}function z(e,t,n){w(n);let r=new Uint8Array(16),o=b(r);return o.setBigUint64(0,BigInt(t),n),o.setBigUint64(8,BigInt(e),n),r}function L(e){return e.byteOffset%4===0}function M(e){return Uint8Array.from(e)}function H(e=32){let t=typeof globalThis=="object"?globalThis.crypto:null;if(typeof t?.getRandomValues!="function")throw new Error("crypto.getRandomValues must be defined");return t.getRandomValues(new Uint8Array(e))}function P(e,t=H){let{nonceLength:n}=e;x(n);let r=(o,i)=>{let f=T(o,i);return i.fill(0),f};return((o,...i)=>({encrypt(f){s(f);let c=t(n),u=e(o,c,...i).encrypt(f);return u instanceof Promise?u.then(g=>r(c,g)):r(c,u)},decrypt(f){s(f);let c=f.subarray(0,n),u=f.subarray(n);return e(o,c,...i).decrypt(u)}}))}export{w as abool,s as abytes,N as aexists,x as anumber,C as aoutput,E as bytesToHex,I as bytesToNumberBE,v as bytesToUtf8,R as checkOpts,_ as clean,D as complexOverlapBytes,T as concatBytes,M as copyBytes,b as createView,k as equalBytes,q as getOutput,U as hexToBytes,B as hexToNumber,L as isAligned32,h as isBytes,A as isLE,P as managedNonce,$ as numberToBytesBE,O as overlapBytes,H as randomBytes,V as u32,z as u64Lengths,S as u8,j as utf8ToBytes,F as wrapCipher};
/*! Bundled license information:

@noble/ciphers/utils.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=utils.mjs.map

/* esm.sh - @noble/curves@2.0.1/utils */
import{abytes as $,anumber as l,bytesToHex as T,concatBytes as E,hexToBytes as I}from"../noble-hashes/utils.mjs";import{abytes as Z,anumber as tt,bytesToHex as et,concatBytes as rt,hexToBytes as nt,isBytes as ot,randomBytes as it}from"../noble-hashes/utils.mjs";var h=BigInt(0),y=BigInt(1);function N(t,e=""){if(typeof t!="boolean"){let r=e&&`"${e}" `;throw new Error(r+"expected boolean, got type="+typeof t)}return t}function d(t){if(typeof t=="bigint"){if(!b(t))throw new Error("positive bigint expected, got "+t)}else l(t);return t}function C(t,e=""){if(!Number.isSafeInteger(t)){let r=e&&`"${e}" `;throw new Error(r+"expected safe integer, got type="+typeof t)}}function v(t){let e=d(t).toString(16);return e.length&1?"0"+e:e}function U(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?h:BigInt("0x"+t)}function j(t){return U(T(t))}function D(t){return U(T(S($(t)).reverse()))}function _(t,e){l(e),t=d(t);let r=I(t.toString(16).padStart(e*2,"0"));if(r.length!==e)throw new Error("number too large");return r}function M(t,e){return _(t,e).reverse()}function O(t){return I(v(d(t)))}function R(t,e){if(t.length!==e.length)return!1;let r=0;for(let n=0;n<t.length;n++)r|=t[n]^e[n];return r===0}function S(t){return Uint8Array.from(t)}function q(t){return Uint8Array.from(t,(e,r)=>{let n=e.charCodeAt(0);if(e.length!==1||n>127)throw new Error(`string contains non-ASCII character "${t[r]}" with code ${n} at position ${r}`);return n})}var b=t=>typeof t=="bigint"&&h<=t;function H(t,e,r){return b(t)&&b(e)&&b(r)&&e<=t&&t<r}function z(t,e,r,n){if(!H(e,r,n))throw new Error("expected valid "+t+": "+r+" <= n < "+n+", got "+e)}function F(t){let e;for(e=0;t>h;t>>=y,e+=1);return e}function G(t,e){return t>>BigInt(e)&y}function P(t,e,r){return t|(r?y:h)<<BigInt(e)}var V=t=>(y<<BigInt(t))-y;function W(t,e,r){if(l(t,"hashLen"),l(e,"qByteLen"),typeof r!="function")throw new Error("hmacFn must be a function");let n=i=>new Uint8Array(i),c=Uint8Array.of(),s=Uint8Array.of(0),u=Uint8Array.of(1),p=1e3,o=n(t),f=n(t),w=0,m=()=>{o.fill(1),f.fill(0),w=0},a=(...i)=>r(f,E(o,...i)),B=(i=c)=>{f=a(s,i),o=a(),i.length!==0&&(f=a(u,i),o=a())},A=()=>{if(w++>=p)throw new Error("drbg: tried max amount of iterations");let i=0,x=[];for(;i<e;){o=a();let g=o.slice();x.push(g),i+=o.length}return E(...x)};return(i,x)=>{m(),B(i);let g;for(;!(g=x(A()));)B();return m(),g}}function J(t,e={},r={}){if(!t||typeof t!="object")throw new Error("expected valid options object");function n(s,u,p){let o=t[s];if(p&&o===void 0)return;let f=typeof o;if(f!==u||o===null)throw new Error(`param "${s}" is invalid: expected ${u}, got ${f}`)}let c=(s,u)=>Object.entries(s).forEach(([p,o])=>n(p,o,u));c(e,!1),c(r,!0)}var K=()=>{throw new Error("not implemented")};function Q(t){let e=new WeakMap;return(r,...n)=>{let c=e.get(r);if(c!==void 0)return c;let s=t(r,...n);return e.set(r,s),s}}export{z as aInRange,N as abool,Z as abytes,tt as anumber,C as asafenumber,q as asciiToBytes,G as bitGet,F as bitLen,V as bitMask,P as bitSet,et as bytesToHex,j as bytesToNumberBE,D as bytesToNumberLE,rt as concatBytes,S as copyBytes,W as createHmacDrbg,R as equalBytes,nt as hexToBytes,U as hexToNumber,H as inRange,ot as isBytes,Q as memoized,K as notImplemented,_ as numberToBytesBE,M as numberToBytesLE,v as numberToHexUnpadded,O as numberToVarBytesBE,it as randomBytes,J as validateObject};
/*! Bundled license information:

@noble/curves/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=utils.mjs.map

/* esm.sh - @noble/curves@2.0.1/abstract/edwards */
import{abool as M,abytes as X,aInRange as k,bytesToHex as P,bytesToNumberLE as N,concatBytes as $,copyBytes as J,hexToBytes as et,isBytes as nt,memoized as Q,notImplemented as W,validateObject as tt,randomBytes as rt}from"../utils.mjs";import{createCurveFields as st,createKeygen as ot,normalizeZ as j,wNAF as it}from"./curve.mjs";var V=BigInt(0),w=BigInt(1),H=BigInt(2),ct=BigInt(8);function at(y,c,g,p){let v=y.sqr(g),l=y.sqr(p),S=y.add(y.mul(c.a,v),l),K=y.add(y.ONE,y.mul(c.d,y.mul(v,l)));return y.eql(S,K)}function lt(y,c={}){let g=st("edwards",y,c,c.FpFnLE),{Fp:p,Fn:v}=g,l=g.CURVE,{h:S}=l;tt(c,{},{uvRatio:"function"});let K=H<<BigInt(v.BYTES*8)-w,e=Z=>p.create(Z),G=c.uvRatio||((Z,n)=>{try{return{isValid:!0,value:p.sqrt(p.div(Z,n))}}catch{return{isValid:!1,value:V}}});if(!at(p,l,l.Gx,l.Gy))throw new Error("bad curve params: generator point");function A(Z,n,o=!1){let r=o?w:V;return k("coordinate "+Z,n,r,K),n}function q(Z){if(!(Z instanceof a))throw new Error("EdwardsPoint expected")}let U=Q((Z,n)=>{let{X:o,Y:r,Z:u}=Z,B=Z.is0();n==null&&(n=B?ct:p.inv(u));let x=e(o*n),E=e(r*n),t=p.mul(u,n);if(B)return{x:V,y:w};if(t!==w)throw new Error("invZ was invalid");return{x,y:E}}),z=Q(Z=>{let{a:n,d:o}=l;if(Z.is0())throw new Error("bad point: ZERO");let{X:r,Y:u,Z:B,T:x}=Z,E=e(r*r),t=e(u*u),s=e(B*B),i=e(s*s),f=e(E*n),h=e(s*e(f+t)),d=e(i+e(o*e(E*t)));if(h!==d)throw new Error("bad point: equation left != right (1)");let m=e(r*u),b=e(B*x);if(m!==b)throw new Error("bad point: equation left != right (2)");return!0});class a{static BASE=new a(l.Gx,l.Gy,w,e(l.Gx*l.Gy));static ZERO=new a(V,w,w,V);static Fp=p;static Fn=v;X;Y;Z;T;constructor(n,o,r,u){this.X=A("x",n),this.Y=A("y",o),this.Z=A("z",r,!0),this.T=A("t",u),Object.freeze(this)}static CURVE(){return l}static fromAffine(n){if(n instanceof a)throw new Error("extended point not allowed");let{x:o,y:r}=n||{};return A("x",o),A("y",r),new a(o,r,w,e(o*r))}static fromBytes(n,o=!1){let r=p.BYTES,{a:u,d:B}=l;n=J(X(n,r,"point")),M(o,"zip215");let x=J(n),E=n[r-1];x[r-1]=E&-129;let t=N(x),s=o?K:p.ORDER;k("point.y",t,V,s);let i=e(t*t),f=e(i-w),h=e(B*i-u),{isValid:d,value:m}=G(f,h);if(!d)throw new Error("bad point: invalid y coordinate");let b=(m&w)===w,Y=(E&128)!==0;if(!o&&m===V&&Y)throw new Error("bad point: x=0 and x_0=1");return Y!==b&&(m=e(-m)),a.fromAffine({x:m,y:t})}static fromHex(n,o=!1){return a.fromBytes(et(n),o)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(n=8,o=!0){return C.createCache(this,n),o||this.multiply(H),this}assertValidity(){z(this)}equals(n){q(n);let{X:o,Y:r,Z:u}=this,{X:B,Y:x,Z:E}=n,t=e(o*E),s=e(B*u),i=e(r*E),f=e(x*u);return t===s&&i===f}is0(){return this.equals(a.ZERO)}negate(){return new a(e(-this.X),this.Y,this.Z,e(-this.T))}double(){let{a:n}=l,{X:o,Y:r,Z:u}=this,B=e(o*o),x=e(r*r),E=e(H*e(u*u)),t=e(n*B),s=o+r,i=e(e(s*s)-B-x),f=t+x,h=f-E,d=t-x,m=e(i*h),b=e(f*d),Y=e(i*d),T=e(h*f);return new a(m,b,T,Y)}add(n){q(n);let{a:o,d:r}=l,{X:u,Y:B,Z:x,T:E}=this,{X:t,Y:s,Z:i,T:f}=n,h=e(u*t),d=e(B*s),m=e(E*r*f),b=e(x*i),Y=e((u+B)*(t+s)-h-d),T=b-m,R=b+m,O=e(d-o*h),F=e(Y*T),I=e(R*O),D=e(Y*O),L=e(T*R);return new a(F,I,L,D)}subtract(n){return this.add(n.negate())}multiply(n){if(!v.isValidNot0(n))throw new Error("invalid scalar: expected 1 <= sc < curve.n");let{p:o,f:r}=C.cached(this,n,u=>j(a,u));return j(a,[o,r])[0]}multiplyUnsafe(n,o=a.ZERO){if(!v.isValid(n))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return n===V?a.ZERO:this.is0()||n===w?this:C.unsafe(this,n,r=>j(a,r),o)}isSmallOrder(){return this.multiplyUnsafe(S).is0()}isTorsionFree(){return C.unsafe(this,l.n).is0()}toAffine(n){return U(this,n)}clearCofactor(){return S===w?this:this.multiplyUnsafe(S)}toBytes(){let{x:n,y:o}=this.toAffine(),r=p.toBytes(o);return r[r.length-1]|=n&w?128:0,r}toHex(){return P(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}let C=new it(a,v.BITS);return a.BASE.precompute(8),a}var _=class{static BASE;static ZERO;static Fp;static Fn;ep;constructor(c){this.ep=c}static fromBytes(c){W()}static fromHex(c){W()}get x(){return this.toAffine().x}get y(){return this.toAffine().y}clearCofactor(){return this}assertValidity(){this.ep.assertValidity()}toAffine(c){return this.ep.toAffine(c)}toHex(){return P(this.toBytes())}toString(){return this.toHex()}isTorsionFree(){return!0}isSmallOrder(){return!1}add(c){return this.assertSame(c),this.init(this.ep.add(c.ep))}subtract(c){return this.assertSame(c),this.init(this.ep.subtract(c.ep))}multiply(c){return this.init(this.ep.multiply(c))}multiplyUnsafe(c){return this.init(this.ep.multiplyUnsafe(c))}double(){return this.init(this.ep.double())}negate(){return this.init(this.ep.negate())}precompute(c,g){return this.init(this.ep.precompute(c,g))}};function dt(y,c,g={}){if(typeof c!="function")throw new Error('"hash" function param is required');tt(g,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});let{prehash:p}=g,{BASE:v,Fp:l,Fn:S}=y,K=g.randomBytes||rt,e=g.adjustScalarBytes||(t=>t),G=g.domain||((t,s,i)=>{if(M(i,"phflag"),s.length||i)throw new Error("Contexts/pre-hash are not supported");return t});function A(t){return S.create(N(t))}function q(t){let s=r.secretKey;X(t,r.secretKey,"secretKey");let i=X(c(t),2*s,"hashedSecretKey"),f=e(i.slice(0,s)),h=i.slice(s,2*s),d=A(f);return{head:f,prefix:h,scalar:d}}function U(t){let{head:s,prefix:i,scalar:f}=q(t),h=v.multiply(f),d=h.toBytes();return{head:s,prefix:i,scalar:f,point:h,pointBytes:d}}function z(t){return U(t).pointBytes}function a(t=Uint8Array.of(),...s){let i=$(...s);return A(c(G(i,X(t,void 0,"context"),!!p)))}function C(t,s,i={}){t=X(t,void 0,"message"),p&&(t=p(t));let{prefix:f,scalar:h,pointBytes:d}=U(s),m=a(i.context,f,t),b=v.multiply(m).toBytes(),Y=a(i.context,b,d,t),T=S.create(m+Y*h);if(!S.isValid(T))throw new Error("sign failed: invalid s");let R=$(b,S.toBytes(T));return X(R,r.signature,"result")}let Z={zip215:!0};function n(t,s,i,f=Z){let{context:h,zip215:d}=f,m=r.signature;t=X(t,m,"signature"),s=X(s,void 0,"message"),i=X(i,r.publicKey,"publicKey"),d!==void 0&&M(d,"zip215"),p&&(s=p(s));let b=m/2,Y=t.subarray(0,b),T=N(t.subarray(b,m)),R,O,F;try{R=y.fromBytes(i,d),O=y.fromBytes(Y,d),F=v.multiplyUnsafe(T)}catch{return!1}if(!d&&R.isSmallOrder())return!1;let I=a(h,O.toBytes(),R.toBytes(),s);return O.add(R.multiplyUnsafe(I)).subtract(F).clearCofactor().is0()}let o=l.BYTES,r={secretKey:o,publicKey:o,signature:2*o,seed:o};function u(t=K(r.seed)){return X(t,r.seed,"seed")}function B(t){return nt(t)&&t.length===S.BYTES}function x(t,s){try{return!!y.fromBytes(t,s)}catch{return!1}}let E={getExtendedPublicKey:U,randomSecretKey:u,isValidSecretKey:B,isValidPublicKey:x,toMontgomery(t){let{y:s}=y.fromBytes(t),i=r.publicKey,f=i===32;if(!f&&i!==57)throw new Error("only defined for 25519 and 448");let h=f?l.div(w+s,w-s):l.div(s-w,s+w);return l.toBytes(h)},toMontgomerySecret(t){let s=r.secretKey;X(t,s);let i=c(t.subarray(0,s));return e(i).subarray(0,s)}};return Object.freeze({keygen:ot(u,z),getPublicKey:z,sign:C,verify:n,utils:E,Point:y,lengths:r})}export{_ as PrimeEdwardsPoint,dt as eddsa,lt as edwards};
/*! Bundled license information:

@noble/curves/abstract/edwards.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=edwards.mjs.map

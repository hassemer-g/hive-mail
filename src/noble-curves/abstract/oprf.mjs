/* esm.sh - @noble/curves@2.0.1/abstract/oprf */
import{abytes as L,asciiToBytes as b,bytesToNumberBE as j,bytesToNumberLE as N,concatBytes as m,numberToBytesBE as _,randomBytes as f,validateObject as U}from"../utils.mjs";import{pippenger as V}from"./curve.mjs";import{_DST_scalar as J}from"./hash-to-curve.mjs";import{getMinHashLength as Q,mapHashToField as W}from"./modular.mjs";function rt(v){U(v,{name:"string",hash:"function",hashToScalar:"function",hashToGroup:"function"});let{name:z,Point:l,hash:F}=v,{Fn:c}=l,w=(t,n)=>v.hashToGroup(t,{DST:m(b("HashToGroup-"),n)}),g=(t,n)=>v.hashToScalar(t,{DST:m(J,n)}),T=(t=f)=>{let n=W(t(Q(c.ORDER)),c.ORDER,c.isLE);return c.isLE?N(n):j(n)},k=(t,n)=>V(l,t,n),K=t=>m(b("OPRFV1-"),new Uint8Array([t]),b("-"+z)),O=K(0),E=K(1),B=K(2);function h(...t){let n=[];for(let s of t)typeof s=="number"?n.push(_(s,2)):typeof s=="string"?n.push(b(s)):(L(s),n.push(_(s.length,2),s));return m(...n)}let A=(...t)=>F(h(...t,"Finalize"));function Z(t,n,s,o){let e=t.toBytes(),i=F(h(e,m(b("Seed-"),o))),r=[];for(let a=0;a<n.length;a++){let u=n[a].toBytes(),y=s[a].toBytes(),p=g(h(i,a,u,y,"Composite"),o);r.push(p)}return r}function H(t,n,s,o){let e=Z(t,n,s,o),i=k(n,e),r=k(s,e);return{M:i,Z:r}}function Y(t,n,s,o,e){let i=Z(n,s,o,e),r=k(s,i),a=r.multiply(t);return{M:r,Z:a}}function D(t,n,s,o,e,i){let[r,a,u,y,p]=[t,n,s,o,e].map(d=>d.toBytes());return g(h(r,a,u,y,p,"Challenge"),i)}function q(t,n,s,o,e,i){let{M:r,Z:a}=Y(n,s,o,e,t),u=T(i),y=l.BASE.multiply(u),p=r.multiply(u),d=D(s,r,a,y,p,t),S=c.sub(u,c.mul(d,n));return m(...[d,S].map(P=>c.toBytes(P)))}function I(t,n,s,o,e){L(e,2*c.BYTES);let{M:i,Z:r}=H(n,s,o,t),[a,u]=[e.subarray(0,c.BYTES),e.subarray(c.BYTES)].map(S=>c.fromBytes(S)),y=l.BASE.multiply(u).add(n.multiply(a)),p=i.multiply(u).add(r.multiply(a)),d=D(n,i,r,y,p,t);if(!c.eql(a,d))throw new Error("proof verification failed")}function R(){let t=T(),n=l.BASE.multiply(t);return{secretKey:c.toBytes(t),publicKey:n.toBytes()}}function x(t,n,s){let o=m(b("DeriveKeyPair"),t),e=m(n,h(s),Uint8Array.of(0));for(let i=0;i<=255;i++){e[e.length-1]=i;let r=v.hashToScalar(e,{DST:o});if(!c.is0(r))return{secretKey:c.toBytes(r),publicKey:l.BASE.multiply(r).toBytes()}}throw new Error("Cannot derive key")}function C(t,n,s=f){let o=T(s),e=w(n,t);if(e.equals(l.ZERO))throw new Error("Input point at infinity");let i=e.multiply(o);return{blind:c.toBytes(o),blinded:i.toBytes()}}function M(t,n,s){let o=c.fromBytes(n),e=w(s,t);if(e.equals(l.ZERO))throw new Error("Input point at infinity");let i=e.multiply(o).toBytes();return A(s,i)}let G={generateKeyPair:R,deriveKeyPair:(t,n)=>x(O,t,n),blind:(t,n=f)=>C(O,t,n),blindEvaluate(t,n){let s=c.fromBytes(t);return l.fromBytes(n).multiply(s).toBytes()},finalize(t,n,s){let o=c.fromBytes(n),i=l.fromBytes(s).multiply(c.inv(o)).toBytes();return A(t,i)},evaluate:(t,n)=>M(O,t,n)};return Object.freeze({name:z,oprf:G,voprf:{generateKeyPair:R,deriveKeyPair:(t,n)=>x(E,t,n),blind:(t,n=f)=>C(E,t,n),blindEvaluateBatch(t,n,s,o=f){if(!Array.isArray(s))throw new Error("expected array");let e=c.fromBytes(t),i=l.fromBytes(n),r=s.map(l.fromBytes),a=r.map(y=>y.multiply(e)),u=q(E,e,i,r,a,o);return{evaluated:a.map(y=>y.toBytes()),proof:u}},blindEvaluate(t,n,s,o=f){let e=this.blindEvaluateBatch(t,n,[s],o);return{evaluated:e.evaluated[0],proof:e.proof}},finalizeBatch(t,n,s){if(!Array.isArray(t))throw new Error("expected array");let o=l.fromBytes(n),e=t.map(r=>r.blinded).map(l.fromBytes),i=t.map(r=>r.evaluated).map(l.fromBytes);return I(E,o,e,i,s),t.map(r=>G.finalize(r.input,r.blind,r.evaluated))},finalize(t,n,s,o,e,i){return this.finalizeBatch([{input:t,blind:n,evaluated:s,blinded:o}],e,i)[0]},evaluate:(t,n)=>M(E,t,n)},poprf:t=>{let n=g(h("Info",t),B),s=l.BASE.multiply(n);return{generateKeyPair:R,deriveKeyPair:(o,e)=>x(B,o,e),blind(o,e,i=f){let r=l.fromBytes(e),a=s.add(r);if(a.equals(l.ZERO))throw new Error("tweakedKey point at infinity");let u=T(i),y=w(o,B);if(y.equals(l.ZERO))throw new Error("Input point at infinity");let p=y.multiply(u);return{blind:c.toBytes(u),blinded:p.toBytes(),tweakedKey:a.toBytes()}},blindEvaluateBatch(o,e,i=f){if(!Array.isArray(e))throw new Error("expected array");let r=c.fromBytes(o),a=c.add(r,n),u=c.inv(a),y=e.map(l.fromBytes),p=y.map(P=>P.multiply(u)),d=l.BASE.multiply(a),S=q(B,a,d,p,y,i);return{evaluated:p.map(P=>P.toBytes()),proof:S}},blindEvaluate(o,e,i=f){let r=this.blindEvaluateBatch(o,[e],i);return{evaluated:r.evaluated[0],proof:r.proof}},finalizeBatch(o,e,i){if(!Array.isArray(o))throw new Error("expected array");let r=o.map(a=>a.evaluated).map(l.fromBytes);return I(B,l.fromBytes(i),r,o.map(a=>a.blinded).map(l.fromBytes),e),o.map((a,u)=>{let y=c.fromBytes(a.blind),p=r[u].multiply(c.inv(y)).toBytes();return A(a.input,t,p)})},finalize(o,e,i,r,a,u){return this.finalizeBatch([{input:o,blind:e,evaluated:i,blinded:r}],a,u)[0]},evaluate(o,e){let i=c.fromBytes(o),r=w(e,B);if(r.equals(l.ZERO))throw new Error("Input point at infinity");let a=c.add(i,n),u=c.inv(a),y=r.multiply(u).toBytes();return A(e,t,y)}}},__tests:{Fn:c}})}export{rt as createORPF};
/*! Bundled license information:

@noble/curves/abstract/oprf.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=oprf.mjs.map

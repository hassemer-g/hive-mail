/* esm.sh - @noble/curves@2.0.1/abstract/modular */
import{abytes as N,anumber as H,bytesToNumberBE as D,bytesToNumberLE as S,numberToBytesBE as y,numberToBytesLE as I,validateObject as Q}from"../utils.mjs";var f=BigInt(0),d=BigInt(1),a=BigInt(2),T=BigInt(3),Y=BigInt(4),M=BigInt(5),U=BigInt(7),V=BigInt(8),G=BigInt(9),Z=BigInt(16);function h(e,t){let n=e%t;return n>=f?n:t+n}function F(e,t,n){return j(_(n),e,t)}function tt(e,t,n){let r=e;for(;t-- >f;)r*=r,r%=n;return r}function O(e,t){if(e===f)throw new Error("invert: expected non-zero number");if(t<=f)throw new Error("invert: expected positive modulus, got "+t);let n=h(e,t),r=t,s=f,l=d,u=d,o=f;for(;n!==f;){let c=r/n,E=r%n,w=s-u*c,g=l-o*c;r=n,n=E,s=u,l=o,u=w,o=g}if(r!==d)throw new Error("invert: does not exist");return h(s,t)}function b(e,t,n){if(!e.eql(e.sqr(t),n))throw new Error("Cannot find square root")}function A(e,t){let n=(e.ORDER+d)/Y,r=e.pow(t,n);return b(e,r,t),r}function J(e,t){let n=(e.ORDER-M)/V,r=e.mul(t,a),s=e.pow(r,n),l=e.mul(t,s),u=e.mul(e.mul(l,a),s),o=e.mul(l,e.sub(u,e.ONE));return b(e,o,t),o}function K(e){let t=_(e),n=C(e),r=n(t,t.neg(t.ONE)),s=n(t,r),l=n(t,t.neg(r)),u=(e+U)/Z;return(o,i)=>{let c=o.pow(i,u),E=o.mul(c,r),w=o.mul(c,s),g=o.mul(c,l),m=o.eql(o.sqr(E),i),q=o.eql(o.sqr(w),i);c=o.cmov(c,E,m),E=o.cmov(g,w,q);let v=o.eql(o.sqr(E),i),R=o.cmov(c,E,v);return b(o,R,i),R}}function C(e){if(e<T)throw new Error("sqrt is not defined for small field");let t=e-d,n=0;for(;t%a===f;)t/=a,n++;let r=a,s=_(e);for(;B(s,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(n===1)return A;let l=s.pow(r,t),u=(t+d)/a;return function(i,c){if(i.is0(c))return c;if(B(i,c)!==1)throw new Error("Cannot find square root");let E=n,w=i.mul(i.ONE,l),g=i.pow(c,t),m=i.pow(c,u);for(;!i.eql(g,i.ONE);){if(i.is0(g))return i.ZERO;let q=1,v=i.sqr(g);for(;!i.eql(v,i.ONE);)if(q++,v=i.sqr(v),q===E)throw new Error("Cannot find square root");let R=d<<BigInt(E-q-1),L=i.pow(w,R);E=q,w=i.sqr(L),g=i.mul(g,w),m=i.mul(m,L)}return m}}function W(e){return e%Y===T?A:e%V===M?J:e%Z===G?K(e):C(e)}var et=(e,t)=>(h(e,t)&d)===d,X=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function nt(e){let t={ORDER:"bigint",BYTES:"number",BITS:"number"},n=X.reduce((r,s)=>(r[s]="function",r),t);return Q(e,n),e}function j(e,t,n){if(n<f)throw new Error("invalid exponent, negatives unsupported");if(n===f)return e.ONE;if(n===d)return t;let r=e.ONE,s=t;for(;n>f;)n&d&&(r=e.mul(r,s)),s=e.sqr(s),n>>=d;return r}function $(e,t,n=!1){let r=new Array(t.length).fill(n?e.ZERO:void 0),s=t.reduce((u,o,i)=>e.is0(o)?u:(r[i]=u,e.mul(u,o)),e.ONE),l=e.inv(s);return t.reduceRight((u,o,i)=>e.is0(o)?u:(r[i]=e.mul(u,r[i]),e.mul(u,o)),l),r}function rt(e,t,n){return e.mul(t,typeof n=="bigint"?O(n,e.ORDER):e.inv(n))}function B(e,t){let n=(e.ORDER-d)/a,r=e.pow(t,n),s=e.eql(r,e.ONE),l=e.eql(r,e.ZERO),u=e.eql(r,e.neg(e.ONE));if(!s&&!l&&!u)throw new Error("invalid Legendre symbol result");return s?1:l?0:-1}function it(e,t){return B(e,t)===1}function k(e,t){t!==void 0&&H(t);let n=t!==void 0?t:e.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}var x=class{ORDER;BITS;BYTES;isLE;ZERO=f;ONE=d;_lengths;_sqrt;_mod;constructor(t,n={}){if(t<=f)throw new Error("invalid field: expected ORDER > 0, got "+t);let r;this.isLE=!1,n!=null&&typeof n=="object"&&(typeof n.BITS=="number"&&(r=n.BITS),typeof n.sqrt=="function"&&(this.sqrt=n.sqrt),typeof n.isLE=="boolean"&&(this.isLE=n.isLE),n.allowedLengths&&(this._lengths=n.allowedLengths?.slice()),typeof n.modFromBytes=="boolean"&&(this._mod=n.modFromBytes));let{nBitLength:s,nByteLength:l}=k(t,r);if(l>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=t,this.BITS=s,this.BYTES=l,this._sqrt=void 0,Object.preventExtensions(this)}create(t){return h(t,this.ORDER)}isValid(t){if(typeof t!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof t);return f<=t&&t<this.ORDER}is0(t){return t===f}isValidNot0(t){return!this.is0(t)&&this.isValid(t)}isOdd(t){return(t&d)===d}neg(t){return h(-t,this.ORDER)}eql(t,n){return t===n}sqr(t){return h(t*t,this.ORDER)}add(t,n){return h(t+n,this.ORDER)}sub(t,n){return h(t-n,this.ORDER)}mul(t,n){return h(t*n,this.ORDER)}pow(t,n){return j(this,t,n)}div(t,n){return h(t*O(n,this.ORDER),this.ORDER)}sqrN(t){return t*t}addN(t,n){return t+n}subN(t,n){return t-n}mulN(t,n){return t*n}inv(t){return O(t,this.ORDER)}sqrt(t){return this._sqrt||(this._sqrt=W(this.ORDER)),this._sqrt(this,t)}toBytes(t){return this.isLE?I(t,this.BYTES):y(t,this.BYTES)}fromBytes(t,n=!1){N(t);let{_lengths:r,BYTES:s,isLE:l,ORDER:u,_mod:o}=this;if(r){if(!r.includes(t.length)||t.length>s)throw new Error("Field.fromBytes: expected "+r+" bytes, got "+t.length);let c=new Uint8Array(s);c.set(t,l?0:c.length-t.length),t=c}if(t.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+t.length);let i=l?S(t):D(t);if(o&&(i=h(i,u)),!n&&!this.isValid(i))throw new Error("invalid field element: outside of range 0..ORDER");return i}invertBatch(t){return $(this,t)}cmov(t,n,r){return r?n:t}};function _(e,t={}){return new x(e,t)}function ot(e,t){if(!e.isOdd)throw new Error("Field doesn't have isOdd");let n=e.sqrt(t);return e.isOdd(n)?n:e.neg(n)}function st(e,t){if(!e.isOdd)throw new Error("Field doesn't have isOdd");let n=e.sqrt(t);return e.isOdd(n)?e.neg(n):n}function z(e){if(typeof e!="bigint")throw new Error("field order must be bigint");let t=e.toString(2).length;return Math.ceil(t/8)}function p(e){let t=z(e);return t+Math.ceil(t/2)}function lt(e,t,n=!1){N(e);let r=e.length,s=z(t),l=p(t);if(r<16||r<l||r>1024)throw new Error("expected "+l+"-1024 bytes of input, got "+r);let u=n?S(e):D(e),o=h(u,t-d)+d;return n?I(o,s):y(o,s)}export{_ as Field,rt as FpDiv,$ as FpInvertBatch,it as FpIsSquare,B as FpLegendre,j as FpPow,W as FpSqrt,st as FpSqrtEven,ot as FpSqrtOdd,z as getFieldBytesLength,p as getMinHashLength,O as invert,et as isNegativeLE,lt as mapHashToField,h as mod,k as nLength,F as pow,tt as pow2,C as tonelliShanks,nt as validateField};
/*! Bundled license information:

@noble/curves/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=modular.mjs.map

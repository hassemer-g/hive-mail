/* esm.sh - @noble/curves@2.0.1/abstract/hash-to-curve */
import{abytes as l,asafenumber as x,asciiToBytes as w,bytesToNumberBE as j,concatBytes as h,isBytes as C,validateObject as L}from"../utils.mjs";import{FpInvertBatch as R,mod as k}from"./modular.mjs";var Z=j;function d(r,t){if(x(r),x(t),r<0||r>=1<<8*t)throw new Error("invalid I2OSP input: "+r);let n=Array.from({length:t}).fill(0);for(let e=t-1;e>=0;e--)n[e]=r&255,r>>>=8;return new Uint8Array(n)}function M(r,t){let n=new Uint8Array(r.length);for(let e=0;e<r.length;e++)n[e]=r[e]^t[e];return n}function O(r){if(!C(r)&&typeof r!="string")throw new Error("DST must be Uint8Array or ascii string");return typeof r=="string"?w(r):r}function U(r,t,n,e){l(r),x(n),t=O(t),t.length>255&&(t=e(h(w("H2C-OVERSIZE-DST-"),t)));let{outputLen:i,blockLen:o}=e,s=Math.ceil(n/i);if(n>65535||s>255)throw new Error("expand_message_xmd: invalid lenInBytes");let c=h(t,d(t.length,1)),f=d(0,o),p=d(n,2),a=new Array(s),m=e(h(f,r,p,d(0,1),c));a[0]=e(h(m,d(1,1),c));for(let u=1;u<=s;u++){let b=[M(m,a[u-1]),d(u+1,1),c];a[u]=e(h(...b))}return h(...a).slice(0,n)}function V(r,t,n,e,i){if(l(r),x(n),t=O(t),t.length>255){let o=Math.ceil(2*e/8);t=i.create({dkLen:o}).update(w("H2C-OVERSIZE-DST-")).update(t).digest()}if(n>65535||t.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return i.create({dkLen:n}).update(r).update(d(n,2)).update(t).update(d(t.length,1)).digest()}function g(r,t,n){L(n,{p:"bigint",m:"number",k:"number",hash:"function"});let{p:e,k:i,m:o,hash:s,expand:c,DST:f}=n;x(s.outputLen,"valid hash"),l(r),x(t);let p=e.toString(2).length,a=Math.ceil((p+i)/8),m=t*o*a,_;if(c==="xmd")_=U(r,f,m,s);else if(c==="xof")_=V(r,f,m,i,s);else if(c==="_internal_pass")_=r;else throw new Error('expand must be "xmd" or "xof"');let u=new Array(t);for(let b=0;b<t;b++){let E=new Array(o);for(let y=0;y<o;y++){let A=a*(y+b*o),v=_.subarray(A,A+a);E[y]=k(Z(v),e)}u[b]=E}return u}function z(r,t){let n=t.map(e=>Array.from(e).reverse());return(e,i)=>{let[o,s,c,f]=n.map(m=>m.reduce((_,u)=>r.add(r.mul(_,e),u))),[p,a]=R(r,[s,f],!0);return e=r.mul(o,p),i=r.mul(i,r.mul(c,a)),{x:e,y:i}}}var F=w("HashToScalar-");function T(r,t,n){if(typeof t!="function")throw new Error("mapToCurve() must be defined");function e(o){return r.fromAffine(t(o))}function i(o){let s=o.clearCofactor();return s.equals(r.ZERO)?r.ZERO:(s.assertValidity(),s)}return{defaults:Object.freeze(n),Point:r,hashToCurve(o,s){let c=Object.assign({},n,s),f=g(o,2,c),p=e(f[0]),a=e(f[1]);return i(p.add(a))},encodeToCurve(o,s){let c=n.encodeDST?{DST:n.encodeDST}:{},f=Object.assign({},n,c,s),p=g(o,1,f),a=e(p[0]);return i(a)},mapToCurve(o){if(n.m===1){if(typeof o!="bigint")throw new Error("expected bigint (m=1)");return i(e([o]))}if(!Array.isArray(o))throw new Error("expected array of bigints");for(let s of o)if(typeof s!="bigint")throw new Error("expected array of bigints");return i(e(o))},hashToScalar(o,s){let c=r.Fn.ORDER,f=Object.assign({},n,{p:c,m:1,DST:F},s);return g(o,1,f)[0][0]}}}export{F as _DST_scalar,T as createHasher,U as expand_message_xmd,V as expand_message_xof,g as hash_to_field,z as isogenyMap};
//# sourceMappingURL=hash-to-curve.mjs.map

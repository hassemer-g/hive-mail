/* esm.sh - @noble/curves@2.0.1/abstract/curve */
import{bitLen as j,bitMask as x}from"../utils.mjs";import{Field as _,FpInvertBatch as k,validateField as z}from"./modular.mjs";var g=BigInt(0),p=BigInt(1);function B(r,t){let e=t.negate();return r?e:t}function $(r,t){let e=k(r.Fp,t.map(n=>n.Z));return t.map((n,o)=>r.fromAffine(n.toAffine(e[o])))}function y(r,t){if(!Number.isSafeInteger(r)||r<=0||r>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+r)}function E(r,t){y(r,t);let e=Math.ceil(t/r)+1,n=2**(r-1),o=2**r,s=x(r),i=BigInt(r);return{windows:e,windowSize:n,mask:s,maxNumber:o,shiftBy:i}}function Z(r,t,e){let{windowSize:n,mask:o,maxNumber:s,shiftBy:i}=e,f=Number(r&o),a=r>>i;f>n&&(f-=s,a+=p);let c=t*n,l=c+Math.abs(f)-1,d=f===0,h=f<0,u=t%2!==0;return{nextN:a,offset:l,isZero:d,isNeg:h,isNegF:u,offsetF:c}}function S(r,t){if(!Array.isArray(r))throw new Error("array expected");r.forEach((e,n)=>{if(!(e instanceof t))throw new Error("invalid point at index "+n)})}function I(r,t){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((e,n)=>{if(!t.isValid(e))throw new Error("invalid scalar at index "+n)})}var F=new WeakMap,R=new WeakMap;function N(r){return R.get(r)||1}function v(r){if(r!==g)throw new Error("invalid wNAF")}var M=class{BASE;ZERO;Fn;bits;constructor(t,e){this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=e}_unsafeLadder(t,e,n=this.ZERO){let o=t;for(;e>g;)e&p&&(n=n.add(o)),o=o.double(),e>>=p;return n}precomputeWindow(t,e){let{windows:n,windowSize:o}=E(e,this.bits),s=[],i=t,f=i;for(let a=0;a<n;a++){f=i,s.push(f);for(let c=1;c<o;c++)f=f.add(i),s.push(f);i=f.double()}return s}wNAF(t,e,n){if(!this.Fn.isValid(n))throw new Error("invalid scalar");let o=this.ZERO,s=this.BASE,i=E(t,this.bits);for(let f=0;f<i.windows;f++){let{nextN:a,offset:c,isZero:l,isNeg:d,isNegF:h,offsetF:u}=Z(n,f,i);n=a,l?s=s.add(B(h,e[u])):o=o.add(B(d,e[c]))}return v(n),{p:o,f:s}}wNAFUnsafe(t,e,n,o=this.ZERO){let s=E(t,this.bits);for(let i=0;i<s.windows&&n!==g;i++){let{nextN:f,offset:a,isZero:c,isNeg:l}=Z(n,i,s);if(n=f,!c){let d=e[a];o=o.add(l?d.negate():d)}}return v(n),o}getPrecomputes(t,e,n){let o=F.get(e);return o||(o=this.precomputeWindow(e,t),t!==1&&(typeof n=="function"&&(o=n(o)),F.set(e,o))),o}cached(t,e,n){let o=N(t);return this.wNAF(o,this.getPrecomputes(o,t,n),e)}unsafe(t,e,n,o){let s=N(t);return s===1?this._unsafeLadder(t,e,o):this.wNAFUnsafe(s,this.getPrecomputes(s,t,n),e,o)}createCache(t,e){y(e,this.bits),R.set(t,e),F.delete(t)}hasCache(t){return N(t)!==1}};function D(r,t,e,n){let o=t,s=r.ZERO,i=r.ZERO;for(;e>g||n>g;)e&p&&(s=s.add(o)),n&p&&(i=i.add(o)),o=o.double(),e>>=p,n>>=p;return{p1:s,p2:i}}function G(r,t,e){let n=r.Fn;S(t,r),I(e,n);let o=t.length,s=e.length;if(o!==s)throw new Error("arrays of points and scalars must have equal length");let i=r.ZERO,f=j(BigInt(o)),a=1;f>12?a=f-3:f>4?a=f-2:f>0&&(a=2);let c=x(a),l=new Array(Number(c)+1).fill(i),d=Math.floor((n.BITS-1)/a)*a,h=i;for(let u=d;u>=0;u-=a){l.fill(i);for(let w=0;w<s;w++){let m=e[w],A=Number(m>>BigInt(u)&c);l[A]=l[A].add(t[w])}let b=i;for(let w=l.length-1,m=i;w>0;w--)m=m.add(l[w]),b=b.add(m);if(h=h.add(b),u!==0)for(let w=0;w<a;w++)h=h.double()}return h}function q(r,t,e){let n=r.Fn;y(e,n.BITS),S(t,r);let o=r.ZERO,s=2**e-1,i=Math.ceil(n.BITS/e),f=x(e),a=t.map(c=>{let l=[];for(let d=0,h=c;d<s;d++)l.push(h),h=h.add(c);return l});return c=>{if(I(c,n),c.length>t.length)throw new Error("array of scalars must be smaller than array of points");let l=o;for(let d=0;d<i;d++){if(l!==o)for(let u=0;u<e;u++)l=l.double();let h=BigInt(i*e-(d+1)*e);for(let u=0;u<c.length;u++){let b=c[u],w=Number(b>>h&f);w&&(l=l.add(a[u][w-1]))}}return l}}function O(r,t,e){if(t){if(t.ORDER!==r)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return z(t),t}else return _(r,{isLE:e})}function P(r,t,e={},n){if(n===void 0&&(n=r==="edwards"),!t||typeof t!="object")throw new Error(`expected valid ${r} CURVE object`);for(let a of["p","n","h"]){let c=t[a];if(!(typeof c=="bigint"&&c>g))throw new Error(`CURVE.${a} must be positive bigint`)}let o=O(t.p,e.Fp,n),s=O(t.n,e.Fn,n),f=["Gx","Gy","a",r==="weierstrass"?"b":"d"];for(let a of f)if(!o.isValid(t[a]))throw new Error(`CURVE.${a} must be valid field element of CURVE.Fp`);return t=Object.freeze(Object.assign({},t)),{CURVE:t,Fp:o,Fn:s}}function W(r,t){return function(n){let o=r(n);return{secretKey:o,publicKey:t(o)}}}export{P as createCurveFields,W as createKeygen,D as mulEndoUnsafe,B as negateCt,$ as normalizeZ,G as pippenger,q as precomputeMSMUnsafe,M as wNAF};
/*! Bundled license information:

@noble/curves/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=curve.mjs.map
